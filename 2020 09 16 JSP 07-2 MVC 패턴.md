# 2020 09 16
=============

## MVC 패턴 구현
Model - View - Controller 모델

- Model : 비즈니스 영역의 로직을 처리한다.
- View : 비즈니스 영역에 대한 프레젠테이션 뷰 (즉, 사용자가 보게 될 경과 화면)를 담당한다.
- Controller : 사용자의 입력 처리와 흐름 제어를 담당한다.

* 컨트롤러 서블릿의 전형적인 구현
```
public vlass ControllerServelt extends HttpServlet
{
	//1단계 n HTTP 요청 받음
	public void doGet(HttpServletRequest request...)
		...

	public void doPost(...)
		...

	//2단계, 요청 분석
	//3단계, 모델을 사용하여 요청한 기능을 수행한다.
	//4단계, request나 session에 처리 결과를 저장
	//5단계, RequestDispatcher를 사용하여 알맞을 뷰로 포워딩
}
```

1. 컨트롤러 예제 만들어 보기

* Java Resource/src/mvc.simple/SimpledController.java
```
package mvc.simple;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


public class SimpleController extends HttpServlet {

	private static final long serialVersionUID = 1L;
	
	// 1단계, HTTP요청 받음
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		processRequest(req, resp);
	}
     
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		processRequest(req, resp);
	}
	
	private void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
	{
		// 2단계, 요청 파악
		// request 객체로부터 사용자의 요청을 파악하는 코드
		String type = req.getParameter("type");
		
		// 3단계, 요청한 기능을 수행한다.
		// 사용자에 요청에 따라 알맞은 코드
		Object resultObject = null;
		if(type == null || type.equals("greeting"))
		{
			resultObject = "안녕하세요";
		}
		else if(type.equals("date"))
		{
			resultObject = new java.util.Date();
		}
		else
		{
			resultObject = "Invalid Type";
		}
		
		// 4단계, request나 session에 처리 결과를 저장
		req.setAttribute("result", resultObject);
		
		// 5단계, RequestDispatcher를 사용하여 알맞은 뷰로 포워딩
		RequestDispatcher dispatcher = req.getRequestDispatcher("/simpleView.jsp");
		dispatcher.forward(req, resp);
	}
}

```

* web.xml
매핑과정
```
<servlet>
	<servlet-name>SimpleController</servlet-name>
	<servlet-class>mvc.simple.SimpleController</servlet-class>
</servlet>

<servlet-mapping>
	<servlet-name>SimpleController</servlet-name>
	<url-pattern>/simple</url-pattern>
</servlet-mapping>
```

- 자바에서 인터페이스를 사용하는 이유 -> 다중 상속을 받기 위해서, 공통의 요소들을 묶을 수 있다.
- 다형성의 뜻 -> 공통의 클래스들을 묶어 해당 클래스 타입들을 받을 수 있다. 단, 역으로 데이터를 넣을 때는 캐스팅을 해주어야 한다.


2. 커맨드 패턴을 이용한 명령어 처리기의 분리

- 각 명령어에 해당하는 로직 처리 코드를 별도 클래스로 작성하여 복잡함을 줄인다 이 방법을 커맨드 패턴이라고 부른다

* web.xml
```
<servlet>
	<servlet-name>ControllerUsingFile</servlet-name>
	<servlet-class>mvc.controller.ControllerUsingFile</servlet-class>
	<init-param>
		<param-name>configFile</param-name>
		<param-value>/WEB-INF/commandHandler.properties</param-value>
	</init-param>
	<load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
	<servlet-name>ControllerUsingFile</servlet-name>
	<url-pattern>/controllserUsingFile</url-pattern>
</servlet-mapping>
```

* WEB-INF/commandHandler.properties
```
hello=mvc.hello.HelloHandler
board = mvc.command.BoardListHandler
form = mvc.command.BoardWriteFormhandler
```

